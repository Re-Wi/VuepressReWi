---
title: python延时相关
date: 2024-11-27 08:36:33
# 设置单个密码
# password: 5cde5596ace9b1e212ab3ace1f083815
# 设置多个密码
password: 
 - 5cde5596ace9b1e212ab3ace1f083815
 - a5db2fd9def8a592756d4ca2b5301c20
hideComments: false
---

`time.perf_counter()` 和 `select.select()` 都是用于精确测量时间或控制延时的工具，但它们的工作原理和精度是不同的，适用于不同的场景。下面我们详细对比一下这两个方法的精度、用途和适用场景。

### 1. **`time.perf_counter()`**
`time.perf_counter()` 是 Python 中的高精度计时器，用于获取当前的时间戳。它的主要用途是测量时间间隔，并且具有最高的精度。

- **精度**：`perf_counter()` 提供的是一个高精度的计时器，通常精度在微秒甚至更高（具体精度取决于操作系统和硬件）。
- **用途**：用于性能测试、测量时间间隔和高精度定时。它并不执行延时，只是用来获取当前时间。
- **特点**： 
  - 精度通常是微秒级别或更高，适合高精度的时间间隔测量。
  - 它是单向计时（即从某个固定的参考点开始递增），适合用作计算程序运行时间。
  - 它并不用于实现延时或等待操作。

**示例**：
```python
import time

start = time.perf_counter()
time.sleep(1)  # 等待 1 秒
end = time.perf_counter()

print(f"Elapsed time: {end - start} seconds")
```

### 2. **`select.select()`**
`select.select()` 是用于多路复用（I/O）操作的系统调用，常用于监控多个文件描述符的状态变化，也可以用来实现延时（等待一段时间）。

- **精度**：`select.select()` 在指定的时间内等待文件描述符准备就绪，它接受一个超时时间参数，这个超时时间的精度通常在毫秒级别（通常较粗糙）。精度受限于操作系统的调度机制和文件描述符的状态变化。
- **用途**：主要用于 I/O 多路复用，等待某个或多个文件描述符变得可读、可写或发生异常。也常用于延时操作，在没有 I/O 操作时可以用来模拟延时。
- **特点**：
  - 当没有 I/O 操作时，`select.select()` 可以用来等待一段时间，超时会触发返回，适用于等待事件发生的场景。
  - 它的精度和延时的实际时间通常取决于操作系统的调度机制，尤其是当延时时间较短时，实际延时可能会比指定的时间稍长。

**示例**：
```python
import select

# 阻塞 1 秒
print("Starting wait...")
select.select([], [], [], 1)  # 等待 1 秒
print("1 second elapsed.")
```

### 比较：
| 特性         | `time.perf_counter()`                    | `select.select()`                              |
| ------------ | ---------------------------------------- | ---------------------------------------------- |
| **主要用途** | 获取高精度时间戳，测量时间间隔           | I/O 多路复用、延时等待                         |
| **精度**     | 微秒级甚至更高，操作系统和硬件决定精度   | 毫秒级精度，受限于操作系统调度和文件描述符状态 |
| **延时实现** | 只能用来测量时间间隔，不适合直接实现延时 | 可用作延时等待，但不适合高精度延时             |
| **适用场景** | 性能测试、时间间隔计算、事件计时         | I/O 等待、轻量级延时等待                       |

### 哪个更精确？
- **`time.perf_counter()`** 提供更高的精度，尤其适用于时间间隔测量。它的精度通常是微秒级别（或更高），而且它不受操作系统调度的影响，适合用于性能测试和高精度的定时任务。
- **`select.select()`** 适用于 I/O 等待或轻量级的阻塞延时，但其延时精度通常较粗，约在毫秒级。延时精度受操作系统调度和文件描述符的状态变化影响，因此并不适合用于高精度的延时。

### 小结：
- 如果你的目标是 **高精度的时间测量** 或 **精确的时间间隔**，推荐使用 **`time.perf_counter()`**。
- 如果你需要在没有 I/O 操作的情况下实现 **阻塞延时**，并且不要求极高的精度，可以使用 **`select.select()`**，尤其是在需要监控文件描述符的同时进行延时等待时。